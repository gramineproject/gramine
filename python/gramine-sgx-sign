#!/usr/bin/python3
# SPDX-License-Identifier: LGPL-3.0-or-later
# Copyright (C) 2021 Intel Corporation
#                    Borys Pop≈Çawski <borysp@invisiblethingslab.com>

import datetime
import os

import click

from graminelibos import (
    Manifest, get_tbssigstruct, sign_with_akv, sign_with_local_key, SGX_LIBPAL, SGX_RSA_KEY_PATH,
)

@click.command()
@click.option('--output', '-o', type=click.Path(), required=True,
              help='Output .manifest.sgx file (manifest augmented with autogenerated fields)')
@click.option('--libpal', '-l', type=click.Path(exists=True, dir_okay=False), default=SGX_LIBPAL,
              help='Input libpal file')
@click.option('--keytype', '-t', type=click.STRING, default='pem',
        help='Type of signing key: "pem" for a local private key in .pem format, '
              '"akv" for Azure Key Vault Managed HSM')
@click.option('--key', '-k', type=click.STRING,
              default=SGX_RSA_KEY_PATH,
              help='Signing key: path to .pem file for a local private key, '
              'vault_url:key_name for Azure Key Vault Managed HSM')
@click.option('--manifest', '-m', 'manifest_file', type=click.File('r', encoding='utf-8'),
              required=True, help='Input .manifest file')
@click.option('--sigfile', '-s', help='Output .sig file')
@click.option('--depfile', type=click.File('w'), help='Generate dependencies for .manifest.sgx '
              'and .sig files')
@click.option('--verbose/--quiet', '-v/-q', default=True, help='Display details (on by default)')
def main(output, libpal, keytype, key, manifest_file, sigfile, depfile, verbose):
    # pylint: disable=too-many-arguments

    manifest = Manifest.load(manifest_file)

    expanded = manifest.expand_all_trusted_files()

    with open(output, 'w', encoding='utf-8') as f:
        manifest.dump(f)

    if not sigfile:
        if manifest_file.name.endswith('.manifest'):
            sigfile = manifest_file.name[:-len('.manifest')]
        else:
            sigfile = manifest_file.name
        sigfile += '.sig'

    today = datetime.date.today()
    sigstruct = get_tbssigstruct(output, today, libpal, verbose=verbose)

    if keytype == 'akv':
        sign_fn = sign_with_akv
        if verbose == True:
            key_details = key.rsplit(':', 1)
            vault_url = key_details[0]
            key_name = key_details[1]
            print('Signing with key', key_name, 'from Azure Key Vault Managed HSM:', vault_url)
    elif keytype == 'pem':
        key = os.fspath(key)
        sign_fn = sign_with_local_key
        if verbose == True:
            print('Signing with local private key:', key)
    else:
        print(f"Invalid keytype specified: `{keytype}`!")
        exit(1)

    sigstruct.sign(sign_fn, key)

    with open(sigfile, 'wb') as f:
        f.write(sigstruct.to_bytes())

    if depfile:
        # Dependencies:
        #
        # - `.manifest.sgx` depends on all files we just expanded
        # - `.sig` additionally depends on libpal and key
        #
        # TODO (Ninja 1.10): We print all these as dependencies for `.manifest.sgx`. This will still
        # cause `.sig` to be rebuilt when necessary: we build both these files together, so it's not
        # possible to rebuild one without the other.
        #
        # This is a workaround for the fact that Ninja prior to version 1.10 does not
        # support depfiles with multiple outputs (and parses such depfiles incorrectly).
        deps = [*expanded, libpal, key]

        depfile.write(f'{output}:')
        for filename in deps:
            depfile.write(f' \\\n\t{filename}')
        depfile.write('\n')


if __name__ == '__main__':
    main() # pylint: disable=no-value-for-parameter
